var JError = require('./JPushError');
var Request = require('request');
var JModel = require('./PushPayload');

var PUSH_API_URL = 'https://api.jpush.cn/v3/push';
var REPORT_API_URL = 'https://report.jpush.cn/v3';
var REPORT_RECEVIED = "/received";
var REPORT_USER = "/users";
var REPORT_MESSAGE = "/messages";
var USER_AGENT = 'JPush-API-NodeJS-Client';
var HOST_NAME_SSL = "https://device.jpush.cn";
var DEVICE_PATH = "/v3/devices";
var TAG_PATH = "/v3/tags";
var ALIAS_PATH = "/v3/aliases";
var VALIDATE = "/validate";
var CONNECT_TIMEOUT = 5 * 1000;
var DEFAULT_MAX_RETRY_TIMES = 3;
var READ_TIMEOUT = 30 * 1000;
// Pattern
var PUSH_PATTERNS = /^[a-zA-Z0-9]{24}/;
var MSG_IDS_PATTERNS = /[^\d,]/;

var HEADER = {
    'User-Agent' : USER_AGENT,
    'Connection' : 'Keep-Alive',
    'Charset' : 'UTF-8',
    'Content-Type' : 'application/json'
};

function JPushClient(options) {
    if (options.appKey || options.masterSecret) {
        throw JError.InvalidArgumentError('appKey and masterSecret are both required.');
    }

    if (typeof options.appKey !== 'string' || typeof options.masterSecret !== 'string'
        || !PUSH_PATTERNS.test(options.appKey) || !PUSH_PATTERNS.test(options.masterSecret)) {

        throw new JError.InvalidArgumentError(
                'appKey and masterSecret format is incorrect. '
                + 'They should be 24 size, and be composed with alphabet and numbers. '
                + 'Please confirm that they are coming from JPush Web Portal.');
    }

    this.appKey = options.appKey;
    this.masterSecret = options.masterSecret;
    this.retryTimes = options.retryTimes | DEFAULT_MAX_RETRY_TIMES;
    this.isDebug = options.isDebug | true;
}


JPushClient.prototype._request = function(options) {
    var isDebug = this.isDebug;
    if (isDebug) {
        console.log("Push URL :" + options.url);
        if (options.body) {
            console.log("Body :" + options.body);
        }
        console.log("Headers :" + JSON.stringify(options.headers));
        console.log("Auth :" + JSON.stringify(options.auth));
        console.log("Method :" + options.method);
        console.log("Times/MaxTryTimes : " + options.times + "/" + options.maxTryTimes);
    }

    var _callback = function(err, res, body) {
        if (err) {
            if (err.code == 'ETIMEDOUT' && err.syscall != 'connect') {
                // response timeout
                return callback(new JError.APIConnectionError('Response timeout. Your request to the server may have already received, please check whether or not to push',
                    true));
            } else if (err.code == 'ENOTFOUND') {
                // unknown host
                return callback(new JError.APIConnectionError('Known host : '
                    + url));
            }
            // other connection error
            if (options.times < options.maxTryTimes) {
                options.times += 1;
                return _request(options);
            } else {
                return options.callback(new JError.APIConnectionError('Connect timeout. Please retry later.'));
            }
        }
        if (res.statusCode == 200) {
            if (body.length != 0) {
                if (isDebug) {
                    console.log("Push Success, response : " + body);
                }
                return options.callback(null, eval('(' + body + ')'));
            } else {
                if (isDebug) {
                    console.log("Push Success, response : " + body);
                }
                return options.callback(null, 200);
            }
        } else {
            if (isDebug) {
                console.log("Push Fail, HttpStatusCode: " + res.statusCode
                    + " result: " + body.toString());
            }
            options.callback(new JError.APIRequestError(res.statusCode, body));
        }
    };

    if (options.method == 'POST' || options.method == 'post') {
        Request.post({
            url : options.url,
            body : options.body,
            auth : {
                user : options.auth.user,
                pass : options.auth.pass
            },
            headers : options.headers,
            timeout : READ_TIMEOUT
        }, _callback);
    }
    if (options.method == 'GET' || options.method == 'get') {
        Request.get({
            url : options.url,
            body : options.body,
            auth : {
                user : options.auth.user,
                pass : options.auth.pass
            },
            headers : options.headers,
            timeout : READ_TIMEOUT
        }, _callback);
    }

    if (options.method == 'DELETE' || options.method == 'delete') {
        Request.del({
            url : options.url,
            body : options.body,
            auth : {
                user : options.auth.user,
                pass : options.auth.pass
            },
            headers : options.headers,
            timeout : READ_TIMEOUT
        }, _callback);
    }
};

JPushClient.prototype.push = function() {
    return new JModel.PushPayload(this);
};

JPushClient.prototype.sendPush = function(payload, callback) {
    return this._request(PUSH_API_URL, payload, HEADER, {
        user : this.appkey,
        pass : this.masterSecret
    }, 'POST', 1, this.retryTimes, this.isDebug, callback);
};